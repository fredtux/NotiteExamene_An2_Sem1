/**
 * 1) a)
	Cazul cel mai simplu este daca avem 1 nod sau nu avem lista de dislike. Atunci returnam true.
	Trecem prin fiecare nod si incepem o parcurgere DFS (in caz ca graful nu este conex). Apoi coloram cu rosu sau negru fiecare nod. Daca gasim un conflict de culori, returnam fals. Daca nu gasim niciun conflict, returnam adevarat.
	Complexitate O(V + E), unde V = n, E = lungimea vectorului dislikes primit ca parametru
    1) b)
	Folosindu-ne de algoritmul anterior, mai adaugam o singura prelucrare pe map-ul de culori si impartim in 2 liste: RED si BLACK.
	Complexitate O(V + E + n), unde V = n, E = lungimea vectorului dislikes primit ca parametru (punctul a) + parcurgerea listei pentru impartire).
 */

#include <bits/stdc++.h>

using namespace std;

class Solution {
private:
    int NOCOL = 0;
    int RED = -1;
    int BLACK = 1;

    unordered_map<int, int> tblColor;

public:
    bool fcolor(int &n, unordered_map<int, vector<int>> &tblDislikes, unordered_map<int, int> &tblColor, int color) {
        // Color the node with the specified color
        tblColor[n] = color;

        // For each dislike node (dn) in dislikes table
        for (int dn: tblDislikes[n]) {
            if (tblColor[dn] == color) {
                return false;
            }

            if (tblColor[dn] == this->NOCOL &&
                !fcolor(dn, tblDislikes, tblColor, (color == this->RED ? this->BLACK : this->RED))) {
                return false;
            }
        }

        return true;
    }

    /**
     * DFS with coloring starting from n
     * @param n
     * @param dislikes
     * @return
     */
    bool possibleBipartition(int n, vector<vector<int>> &dislikes) {


        int i;

        // If there is 1 node or no dislikes
        if (n == 1 || dislikes.size() == 0)
            return true;

        // Keep the dislikes as an unordred map for quick access
        unordered_map<int, vector<int>> tblDislikes;

        // Keep the color for each person
        unordered_map<int, int> tblColor;

        // Populate the dislikes table
        int n1, n2;
        for (vector<int> relation: dislikes) {
            n1 = relation[0];
            n2 = relation[1];

            tblDislikes[n1].push_back(n2);
            tblDislikes[n2].push_back(n1);
        }

        // DFS from each node
        for (int i = 1; i <= n; ++i) {
            if (tblColor[i] == this->NOCOL && !fcolor(i, tblDislikes, tblColor, this->RED)) {
                return false;
            }
        }

        this->tblColor = tblColor;

        return true;
    }

    /**
     * Used the array generated by the previous method
     * @param n
     * @param dislikes
     * @return
     */
    vector<vector<int>> possibleBipartition2(int n, vector<vector<int>> &dislikes) {
        vector<vector<int>> result(2, vector<int>(0));

        // Get the results from the last algorithm
        for (int i = 1; i <= n; ++i) {
            if (tblColor[i] == this->RED)
                result[0].push_back(i);
            else
                result[1].push_back(i);
        }

        return result;
    }
};

int main() {

    Solution *sol = new Solution();

    int n = 4;
    vector<vector<int>> dislikes = {{1, 2},
                                    {1, 3},
                                    {2, 4}};

    bool isPossible = sol->possibleBipartition(n, dislikes);

    cout << (isPossible ? "true" : "false") << "\n";

    // Only break into two vectors if it's possible
    if (isPossible) {
        vector<vector<int>> bip = sol->possibleBipartition2(n, dislikes);

        cout << "RED: ";
        for (int node: bip[0]) {
            cout << node << ", ";
        }

        cout << '\n';
        cout << "BLACK: ";
        for (int node: bip[1]) {
            cout << node << ", ";
        }

    }

    return 0;
}

/**
 * 2)
	https://csacademy.com/submission/3999750/

	Permutarile nu se pot face pe intreaga lista de vecini, deoarece DFS impune restrictia ca daca nodul Y are ca tata unic nodul X, atunci nodul Y il va succeda pe X. Asadar permutarea se face doar in randul copiilor lui X. De asemenea, permutarea reprezinta tot o parcurgere DFS, dar cu o alta lista de adiacenta. De aceea este necesara modificarea listei de adiacenta inainte de parcurgerea noastra DFS astfel incat sa se reflecte ordinea din permutare. Apoi se compara parcurgerea DFS cu lista de permutari.
	Complexitate O(n * log n + n), unde n este numarul nodurilor. Complexitatea n * log n vine de la faptul ca avem n sortari pe vecinii fiecarui nod, iar ultimul n de la parcurgerea DFS.
 */

#include <bits/stdc++.h>

using namespace std;

int n, m, i, j, tmp, tmp2;
unordered_map<int, int> permutations;
vector<int> vPermutations;
vector<vector<int>> graph;
vector<int> dfsSorted;
unordered_map<int, bool> visited;
bool result = false;

/**
 * Simple DFS on the graph
 * @param n
 */
void dfs(int n) {
    visited[n] = true;
    dfsSorted.push_back(n);

    for (const int &vecin: graph[n])
        if (!visited[vecin])
            dfs(vecin);
}

int main() {
    cin >> n >> m;

    for (i = 0; i < n; ++i) {
        cin >> tmp;
        vPermutations.push_back(tmp); // More space, less time
        permutations[tmp] = i;
        visited[n] = false; // Why iterate again to set visited as false
    }

    graph.resize(n + 1);

    for (i = 0; i < m; ++i) {
        cin >> tmp;
        cin >> tmp2;

        graph[tmp].push_back(tmp2);
        graph[tmp2].push_back(tmp);
    }

    // Sort all the nodes by their position in the permutation
    for (int i = 1; i <= n; ++i)
        sort(graph[i].begin(), graph[i].end(), [&](int n1, int n2) -> bool {
            return permutations[n1] < permutations[n2];
        });

    // This is a connected graph starting with 1
    dfs(1);

    result = equal(vPermutations.begin(), vPermutations.end(), dfsSorted.begin());

    cout << (result ? 1 : 0);


    return 0;
}

/**
 * 3) a)
	Cazul de baza este atunci cand nu exista prerequisites si intoarcem un vector cu toate cursurile.
	Vom inversa relatia din prerequisites pentru a face o lista de adiacenta. Apoi o vom sorta topologic astfel incat sa stim ca daca pornim din primul nod, vom ajunge la ultimul. Evident ca nu putem sorta topologic un graf orientat cu cel putin 1 ciclu. Pentru sortarea topologica, vom folosi un DFS cu o stiva pusa la sfarsit.
	Complexitate: O(V), unde V = n data de parcurgerea DFS.

    3) b)
	Vom folosi aceeasi functie de sortare topologica si vom adauga intr-un vector de ciclu toate cazurile in care sortarea topologica esua din cauza ciclului. La sfarsit vom inversa vectorul de ciclu si vom adauga primul element la coada pentru a pastra structura din cerinta.
	Complexitate: O(V), unde V = n data de parcurgerea DFS.
 */

#include <bits/stdc++.h>

using namespace std;

ostream &operator<<(ostream &out, vector<int> v) {
    for (auto x: v) {
        out << x << " ";
    }
    out << "\n";

    return out;
}

class Solution {
private:
    vector<vector<int>> graph;
    vector<bool> visited;
    vector<bool> cycleTracker;
    vector<int> indegree;
    queue<int> q;
    stack<int> st;
    vector<int> cycle;

public:
    bool topSort(const int &n) {
        visited[n] = true;
        cycleTracker[n] = true;

        for (const int &vecin: graph[n]) {
            if (cycleTracker[vecin]) {
                return false;
            }

            if (!visited[vecin] && !topSort(vecin)) {
                return false;
            }
        }

        cycleTracker[n] = false;
        st.push(n);

        return true;
    }

    vector<int> findOrder(int numCourses, vector<vector<int>> &prerequisites) {
        vector<int> result = {};

        if (prerequisites.empty()) {
            for (int i = 0; i < numCourses; ++i) {
                result.push_back(i);
            }

            return result;
        }

        graph.resize(numCourses + 1);
        visited.resize(numCourses + 1, false);
        cycleTracker.resize(numCourses + 1, false);

        // Construct the graph in the reverse prerequisites order
        for (const vector<int> &pre: prerequisites) {
            graph[pre[1]].push_back(pre[0]);
        }

        // Do a topological sort from each node
        for (int i = 0; i < numCourses; ++i) {
            if (!visited[i] && !topSort(i)) {
                return result;
            }
        }

        while (!st.empty()) {
            result.push_back(st.top());
            st.pop();
        }

        return result;
    }

    bool cycleMaker(const int &n) {
        visited[n] = true;
        cycleTracker[n] = true;

        for (const int &vecin: graph[n]) {
            if (cycleTracker[vecin]) {
                cycleTracker.push_back(vecin);
                return false;
            }

            if (!visited[vecin] && !cycleMaker(vecin)) {
                if (cycle.size() <= 1 || cycle[0] != cycle[cycle.size() - 1]) {
                    cycle.push_back(vecin);
                }
                return false;
            }
        }

        cycleTracker[n] = false;
        st.push(n);

        return true;
    }

    vector<int> findCycle(int numCourses, vector<vector<int>> &prerequisites) {
        vector<int> result = {};

        graph.erase(graph.begin(), graph.end());
        visited.erase(visited.begin(), visited.end());
        cycleTracker.erase(cycleTracker.begin(), cycleTracker.end());
        graph.resize(numCourses + 1);
        visited.resize(numCourses + 1, false);
        cycleTracker.resize(numCourses + 1, false);

        // Construct the graph in the reverse prerequisites order
        for (const vector<int> &pre: prerequisites) {
            graph[pre[1]].push_back(pre[0]);
        }

        for (int i = 0; i < numCourses; ++i) {
            if (!visited[i] && !cycleMaker(i)) {
                reverse(cycle.begin(), cycle.end());
                cycle.push_back(cycle[0]);
                return cycle;
            }
        }

        return cycle;
    }
};

int main() {
//    int numCourses = 4;
//    vector<vector<int>> prerequisites = {{1, 0},
//                                         {2, 0},
//                                         {3, 1},
//                                         {3, 2}};

//    int numCourses = 2;
//    vector<vector<int>> prerequisites = {{0,1}};

    int numCourses = 5;
    vector<vector<int>> prerequisites = {{1, 0},
                                         {2, 1},
                                         {3, 2},
                                         {4, 3},
                                         {1, 4}};

    vector<int> result;

    Solution *sol = new Solution();
    result = sol->findOrder(numCourses, prerequisites);

    cout << result << "\n";

    if (result.empty()) {
        cout << sol->findCycle(numCourses, prerequisites);
    }

    return 0;
}

/**
 * 4)
	https://www.infoarena.ro/job_detail/2928902

	Folosim algoritmul lui Kosaraju. Pentru acest lucru stocam atat graful cat si transpusa, facem sortare topologica pe graf, apoi din stiva rezultata facem o parcurgere DFS din fiecare nod pe transpusa. Fiecare nod nou nevizitat din care pornim DFS-ul pe transpusa va determina o noua componenta tare conexa.
	Complexitate: O(V + E), unde V = n si E = m, deoarece avem parcurgere DFS.
	Surse de inspiratie:
	https://en.wikipedia.org/wiki/Kosaraju's_algorithm
	https://www.youtube.com/watch?v=zdlkzVCbSAA
 */

#include <bits/stdc++.h>

using namespace std;

ostream &operator<<(ostream &out, vector<int> v) {
    for (auto x: v) {
        out << x << " ";
    }
    out << "\n";

    return out;
}

ifstream fin("ctc.in");
ofstream fout("ctc.out");

int n, m, i, j, tmp1, tmp2, ctc;
vector<vector<int>> graf;
vector<bool> visited;
vector<vector<int>> transpus;
stack<int> tst;
vector<vector<int>> result;
vector<int> partial;

/**
 * Sortare topologica
 * @param n
 */
inline void topSort(const int &n) {
    visited[n] = true;

    for (const int &vecin: graf[n]) {
        if (!visited[vecin]) {
            topSort(vecin);
        }
    }

    tst.push(n);
}

/**
 * Parcurgere DFS
 * @param n
 */
void dfs(const int &n) {
    visited[n] = true;

    for (const int &vecin: transpus[n]) {
        if (!visited[vecin]) {
            dfs(vecin);
        }
    }

    partial.push_back(n);
}

int main() {
    fin >> n >> m;

    graf.resize(n + 1);
    visited.resize(n + 1, false);
    transpus.resize(n + 1);

    // Construim graful si transpusa sa
    for (i = 0; i < m; ++i) {
        fin >> tmp1 >> tmp2;
        graf[tmp1].push_back(tmp2);
        transpus[tmp2].push_back(tmp1);
    }

    // Facem sortare topologica pe graf
    for (i = 1; i <= n; ++i) {
        if (!visited[i])
            topSort(i);
    }

    visited.erase(visited.begin(), visited.end());
    visited.resize(n + 1, false);

    // Trecem prin stiva sortarii topologice pana ramanem fara elemente
    while (!tst.empty()) {
        tmp1 = tst.top();
        tst.pop();

        // Daca elementul nu a fost vizitat, pornim un DFS in trasnpusa
        if (!visited[tmp1]) {
            ++ctc;

            partial.erase(partial.begin(), partial.end());

            dfs(tmp1);

            result.push_back(partial);
        }
    }

    fout << ctc << '\n';

    for (const vector<int> &comp: result)
        fout << comp;

    return 0;
}

/**
 * 5)
	Facem 2 parcurgeri BFS cu masurarea distantei din fiecare punct de control. Daca distanta este necalculata sau mai mica, atunci o stocam pe cea calculata. La sfarsit afisam.
	Complexitate: O(2*(V+E)), unde V = n, E = m, deoarece avem 2 parcurgeri BFS.
 */
#include <bits/stdc++.h>

using namespace std;

ostream &operator<<(ostream &out, vector<int> v) {
    bool i = false;
    for (auto x: v) {
        if (!i) {
            i = ~i;
            continue;
        }
        out << x << " ";
    }
    out << "\n";

    return out;
}

ifstream fin("graf.in");
ofstream fout("graf.out");

int n, m, tmp1, tmp2, p1, p2, i, j;
vector<vector<int>> graf;
vector<int> result;
vector<bool> visited;
vector<int> distanta;
queue<int> q;

/**
 * BFS cu calculul distantei
 * @param n
 * @param dist
 */
void bfs(const int &n) {
    visited[n] = true;
    q.push(n);

    while (!q.empty()) {
        tmp1 = q.front();
        q.pop();

        for (const int &vecin: graf[tmp1]) {
            if (!visited[vecin]) {
                if (distanta[vecin] == 0 || distanta[vecin] > distanta[tmp1])
                    distanta[vecin] = distanta[tmp1] + 1;

                visited[vecin] = true;
                q.push(vecin);
            }
        }
    }
}

int main() {
    fin >> n >> m;

    graf.resize(n + 1);
    result.resize(n + 1);
    visited.resize(n + 1, false);
    distanta.resize(n + 1, 0);

    for (i = 0; i < m; ++i) {
        fin >> tmp1 >> tmp2;
        graf[tmp1].push_back(tmp2);
        graf[tmp2].push_back(tmp1);
    }

    fin >> p1 >> p2;

    // Pornesc un BFS din punctul de control 1, avand grija sa nu ating punctul de control 2
    visited[p2] = true;
    bfs(p1);

    visited.erase(visited.begin(), visited.end());
    visited.resize(n + 1, false);

    // Pornesc un BFS din punctul de control 2, avand grija sa nu ating punctul de control 1
    visited[p1] = true;
    bfs(p2);

    fout << distanta;

    return 0;
}